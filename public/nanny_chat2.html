<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Chat Interface</title>
    <link
      rel="stylesheet"
      href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css"
    />
    <script src="https://unpkg.com/vue@3/dist/vue.global.prod.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/firebase/10.7.1/firebase-app-compat.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/firebase/10.7.1/firebase-auth-compat.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/firebase/10.7.1/firebase-firestore-compat.js"></script>
    <script src="https://unpkg.com/lucide@latest"></script>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: "Segoe UI", sans-serif;
        background-color: white;
        padding: 15px 0;
        height: 100vh;
      }

      .app-container {
        max-width: 1400px;
        padding: 20px 0;
        margin: 20px auto;
        height: calc(100vh - 40px);
        background-color: white;
        border-radius: 12px;
        overflow: hidden;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
      }

      .container {
        display: flex;
        height: 100%;
      }

      /* Sidebar styling */
      .chat-list {
        width: 350px;
        background-color: #f8f9fa;
        border-right: 1px solid #eee;
        display: flex;
        flex-direction: column;
        height: 100%;
      }

      /* Add a wrapper for the scrollable content */
      .chat-list-scrollable {
        flex: 1;
        overflow-y: auto;
        overflow-x: hidden;
      }

      .sidebar-header {
        padding: 20px;
        border-bottom: 1px solid #eee;
        display: flex;
        align-items: center;
        gap: 10px;
      }

      .sidebar-icons {
        display: flex;
        padding: 15px;
        gap: 15px;
        border-bottom: 1px solid #eee;
      }

      .sidebar-icons i {
        padding: 10px;
        border-radius: 8px;
        cursor: pointer;
      }

      .sidebar-icons i:hover {
        background-color: #f0f2f5;
      }

      .chat-preview {
        padding: 12px 15px;
        display: flex;
        align-items: flex-start;
        gap: 12px;
        cursor: pointer;
        transition: background-color 0.2s;
        border-bottom: 1px solid #eee;
      }

      .chat-preview:hover {
        background-color: #f0f2f5;
      }

      .chat-preview.active {
        background-color: #e8eaf6;
      }

      .chat-preview img {
        width: 40px;
        height: 40px;
        border-radius: 50%;
        object-fit: cover;
      }

      .chat-preview-content {
        flex: 1;
        min-width: 0;
      }

      .last-message {
        color: #666;
        font-size: 0.9em;
        margin-top: 4px;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        max-width: 250px;
      }

      .chat-preview-time {
        font-size: 0.75rem;
        color: #666;
        white-space: nowrap;
      }

      /* Main chat area styling */
      .chat-details {
        flex-grow: 1;
        display: flex;
        flex-direction: column;
      }

      .chat-header {
        padding: 15px 20px;
        border-bottom: 1px solid #eee;
        display: flex;
        align-items: center;
        justify-content: space-between;
        background-color: white;
      }

      .chat-header-left {
        display: flex;
        align-items: center;
        gap: 12px;
      }

      .chat-header-right {
        display: flex;
        gap: 20px;
      }

      .chat-header img {
        width: 40px;
        height: 40px;
        border-radius: 50%;
      }

      .chat-messages {
        flex-grow: 1;
        padding: 20px;
        overflow-y: auto;
        background-color: #f0f2f5;
      }

      .message {
        max-width: 70%;
        min-width: 80px;
        margin: 10px 0;
        padding: 12px 16px;
        padding-bottom: 20px;
        border-radius: 20px;
        position: relative;
        display: inline-block; /* This makes the bubble wrap to content */
        word-wrap: break-word;
        width: fit-content; /* This makes the bubble fit the content */
        line-height: 1.4; /* Add line height for better text spacing */
        transition: background-color 0.3s ease;
      }

      .message.sent {
        background-color: #6c5ce7;
        color: white;
        margin-left: auto;
        border-bottom-right-radius: 4px;
        float: right;
        clear: both;
      }

      .message.sent .timestamp {
        color: rgba(255, 255, 255, 0.7);
      }

      .message.received {
        background-color: white;
        color: #1a1a1a;
        border-bottom-left-radius: 4px;
        float: left;
        clear: both;
      }

      .message.received .timestamp {
        color: rgba(0, 0, 0, 0.5);
      }

      /* Animation for highlighted message */
      .message.highlighted {
        animation: highlight-fade 2s ease-out;
      }

      .message-container {
        margin: 10px 0;
        clear: both;
        overflow: hidden;
        display: flex;
        flex-direction: column;
      }

      .chat-input-container {
        padding: 20px;
        background-color: white;
        border-top: 1px solid #eee;
      }

      .chat-input {
        display: flex;
        align-items: center;
        gap: 8px;
        background-color: white;
        border: 1px solid #e0e0e0;
        padding: 8px 15px;
        border-radius: 24px;
      }

      .chat-input input {
        flex-grow: 1;
        border: none;
        background: transparent;
        padding: 8px;
        outline: none;
        font-size: 15px;
      }

      .chat-input button {
        background-color: transparent;
        border: none;
        cursor: pointer;
        padding: 8px;
      }

      .send-button {
        background: transparent;
        border: none;
        padding: 8px;
        cursor: pointer;
        color: #6c5ce7;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: opacity 0.2s;
      }

      .send-button.disabled {
        opacity: 0.5;
        cursor: default;
        color: #666;
      }

      .send-button:not(.disabled):hover {
        opacity: 0.8;
      }

      .search-bar {
        position: relative;
        padding: 15px;
        border-bottom: 1px solid #eee;
      }

      .search-bar input {
        width: 100%;
        padding: 10px 15px;
        padding-left: 40px;
        border: none;
        background-color: #f0f2f5;
        border-radius: 20px;
        outline: none;
        font-size: 14px;
      }

      .search-bar::before {
        content: "";
        position: absolute;
        left: 25px;
        top: 50%;
        transform: translateY(-50%);
        width: 20px;
        height: 20px;
        background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='24' height='24' viewBox='0 0 24 24' fill='none' stroke='%23666' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Ccircle cx='11' cy='11' r='8'%3E%3C/circle%3E%3Cline x1='21' y1='21' x2='16.65' y2='16.65'%3E%3C/line%3E%3C/svg%3E");
        background-size: contain;
        background-repeat: no-repeat;
        opacity: 0.5;
      }

      /* Search Results Styling */
      .search-section {
        padding-bottom: 10px;
      }

      .search-section-header {
        padding: 10px 15px;
        font-weight: 600;
        color: #666;
        background-color: #f8f9fa;
        font-size: 13px;
        text-transform: uppercase;
      }

      /* Highlight styling */
      mark {
        background-color: #fff3cd;
        padding: 0 2px;
        border-radius: 2px;
      }

      /* Message preview in search results */
      .message-preview {
        color: #666;
        font-size: 0.9em;
        margin-top: 4px;
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
      }

      /* Animation for highlighted message */
      .highlighted {
        animation: highlight-fade 2s ease-out;
      }

      @keyframes highlight-fade {
        0% {
          background-color: #fff3cd;
        }
        100% {
          background-color: transparent;
        }
      }

      .user-avatar {
        position: relative;
        width: 48px; /* Increase size and make width/height equal */
        height: 48px;
        flex-shrink: 0; /* Prevent avatar from shrinking */
      }

      .user-avatar img {
        width: 100%;
        height: 100%;
        border-radius: 50%;
        object-fit: cover; /* This ensures the image maintains its aspect ratio */
      }

      .timestamp {
        font-size: 0.75rem;
        position: absolute;
        bottom: 4px;
        right: 12px;
        opacity: 0.7;
        white-space: nowrap;
        text-align: right;
        min-width: 55px;
      }

      /* Update the no-chat-selected styling */
      .no-chat-selected {
        display: flex;
        align-items: center;
        justify-content: center;
        height: 100%;
        background-color: #f8f9fa;
      }

      .no-chat-selected h2 {
        color: #6c757d;
        font-size: 1.5rem;
        font-weight: 500;
        text-align: center;
        padding: 20px;
        max-width: 80%;
        line-height: 1.4;
      }

      /* Add styles for the date separator */
      .date-separator {
        text-align: center;
        margin: 20px 0;
        position: relative;
      }

      .date-label {
        background-color: rgba(0, 0, 0, 0.2);
        color: white;
        padding: 4px 12px;
        border-radius: 16px;
        font-size: 0.85rem;
        display: inline-block;
      }
    </style>
  </head>
  <body>
    <header>
      <div id="navbar"></div>
    </header>
    <div id="app" class="app-container">
      <div class="container">
        <!-- Sidebar -->
        <div class="chat-list">
          <div class="sidebar-header">
            <div class="user-avatar">
              <img
                :src="currentUserProfilePic"
                alt="Current User"
                @error="handleImageError($event)"
              />
            </div>
            <h3>Chats</h3>
          </div>

          <div class="search-bar">
            <input
              type="text"
              v-model="searchTerm"
              @input="handleSearch"
              placeholder="Search..."
            />
          </div>

          <!-- Add wrapper for scrollable content -->
          <div class="chat-list-scrollable">
            <!-- Search Results -->
            <div v-if="searchTerm.trim()" class="search-results">
              <!-- Contacts Section -->
              <div v-if="searchResults.contacts.length" class="search-section">
                <div class="search-section-header">Chats</div>
                <div
                  v-for="contact in searchResults.contacts"
                  :key="'contact-' + contact.userId"
                  class="chat-preview"
                  @click="selectChat(contact)"
                >
                  <div class="user-avatar">
                    <img
                      :src="contact.profilePictureUrl"
                      :alt="contact.firstName"
                      @error="handleImageError($event)"
                    />
                  </div>
                  <div class="chat-preview-content">
                    <h4 v-html="contact.highlightedName"></h4>
                  </div>
                </div>
              </div>

              <!-- Message Section -->
              <div v-if="searchResults.messages.length" class="search-section">
                <div class="search-section-header">Messages</div>
                <div
                  v-for="message in searchResults.messages"
                  :key="'message-' + message.messageId"
                  class="chat-preview"
                  @click="scrollToMessage(message.messageId, message.userId)"
                >
                  <div class="user-avatar">
                    <img
                      :src="message.profilePictureUrl"
                      :alt="message.firstName"
                      @error="handleImageError($event)"
                    />
                  </div>
                  <div class="chat-preview-content">
                    <h4>{{ message.firstName }} {{ message.lastName }}</h4>
                    <p
                      class="message-preview"
                      v-html="message.highlightedMessage"
                    ></p>
                    <small>{{ formatTimestamp(message.timestamp) }}</small>
                  </div>
                </div>
              </div>
            </div>

            <!-- Regular Chat List -->
            <div v-else>
              <div
                v-for="chat in sortedChats"
                :key="chat.userId"
                :class="['chat-preview', { active: selectedChat && selectedChat.userId === chat.userId }]"
                @click="selectChat(chat)"
              >
                <div class="user-avatar">
                  <img
                    :src="chat.profilePictureUrl"
                    :alt="chat.firstName"
                    @error="handleImageError($event)"
                  />
                </div>
                <div>
                  <h4>{{ chat.firstName }} {{ chat.lastName }}</h4>
                  <p class="last-message">{{ chat.lastMessage }}</p>
                  <small>{{ formatTimestamp(chat.timestamp) }}</small>
                </div>
              </div>
            </div>
          </div>
        </div>

        <!-- Main Chat Area -->
        <div class="chat-details">
          <template v-if="selectedChat">
            <div class="chat-header">
              <div class="chat-header-left">
                <div class="user-avatar">
                  <img
                    :src="selectedChat.profilePictureUrl"
                    :alt="selectedChat.firstName"
                    @error="handleImageError($event)"
                  />
                </div>
                <div>
                  <h3>
                    {{ selectedChat.firstName }} {{ selectedChat.lastName }}
                  </h3>
                </div>
              </div>
            </div>

            <div class="chat-messages" ref="messageContainer">
              <div
                v-for="group in groupMessagesByDate(selectedChatMessages)"
                :key="group.date"
              >
                <!-- Date separator -->
                <div class="date-separator">
                  <span class="date-label"
                    >{{ formatDateForGroup(group.date) }}</span
                  >
                </div>

                <!-- Messages for this date -->
                <div
                  v-for="message in group.messages"
                  :key="message.timestamp"
                  class="message-container"
                >
                  <div
                    :data-message-id="message.id"
                    :class="['message', message.from_user_id === currentUserId ? 'sent' : 'received', { 'highlighted' : message.id === highlightedMessage }]"
                  >
                    {{ message.message }}
                    <div class="timestamp">
                      {{ formatMessageTime(message.timestamp) }}
                    </div>
                  </div>
                </div>
              </div>
            </div>

            <div class="chat-input-container">
              <div class="chat-input">
                <input
                  type="text"
                  v-model.trim="newMessage"
                  @keyup.enter="sendMessage"
                  placeholder="Write a message..."
                />
                <button
                  class="send-button"
                  :class="{ 'disabled': !canSendMessage }"
                  @click="sendMessage"
                  :disabled="!canSendMessage"
                >
                  <i data-lucide="send"></i>
                </button>
              </div>
            </div>
          </template>
          <div v-else class="no-chat-selected">
            <h2>Select a chat to start messaging</h2>
          </div>
        </div>
      </div>
    </div>

    <!-- Your existing scripts remain the same -->
    <script type="module">
      // Import necessary modules from Firebase
      import { firebaseConfig } from "./backend/firebase-config.js";
      firebase.initializeApp(firebaseConfig);
      const db = firebase.firestore();
      const auth = firebase.auth();

      const app = Vue.createApp({
        data() {
          return {
            currentUserId: null,
            currentUserProfilePic: "/api/placeholder/40/40",
            chats: [],
            selectedChat: null,
            selectedChatMessages: [],
            newMessage: "",
            unsubscribe: null,
            messageUnsubscribe: null,
            searchTerm: "",
            searchResults: {
              contacts: [], // for name matches
              messages: [], // for message content matches
            },
            originalChats: [],
            highlightedMessageId: null,
          };
        },

        computed: {
          sortedChats() {
            const chatsToSort = this.searchTerm
              ? this.searchResults
              : this.chats;
            return [...chatsToSort].sort((a, b) => b.timestamp - a.timestamp);
          },

          canSendMessage() {
            return this.newMessage.trim().length > 0;
          },
        },

        // Add debounce to prevent too many searches
        created() {
          this.handleSearch = _.debounce(this.handleSearch, 300);
        },

        methods: {
          handleImageError(event) {
            event.target.src = "/api/placeholder/40/40"; // Fallback to placeholder
          },

          // Chat time formatting
          formatChatTime(timestamp) {
            if (!timestamp) return "";

            const date = new Date(timestamp);
            const now = new Date();
            const yesterday = new Date(now);
            yesterday.setDate(yesterday.getDate() - 1);

            // Check if it's today
            if (date.toDateString() === now.toDateString()) {
              return date.toLocaleTimeString("en-US", {
                hour: "numeric",
                minute: "2-digit",
                hour12: true,
              });
            }

            // Check if it's yesterday
            if (date.toDateString() === yesterday.toDateString()) {
              return "Yesterday";
            }

            // If it's this year, show date without year
            if (date.getFullYear() === now.getFullYear()) {
              return date.toLocaleDateString("en-US", {
                month: "short",
                day: "numeric",
              });
            }

            // If it's a different year, include the year
            return date.toLocaleDateString("en-US", {
              month: "short",
              day: "numeric",
              year: "numeric",
            });
          },

          formatMessageTime(timestamp) {
            if (!timestamp) return "";
            const date = new Date(timestamp);
            return date.toLocaleTimeString("en-US", {
              hour: "numeric",
              minute: "2-digit",
              hour12: true,
            });
          },

          formatDateForGroup(timestamp) {
            if (!timestamp) return "";
            const date = new Date(timestamp);
            const today = new Date();
            const yesterday = new Date(today);
            yesterday.setDate(yesterday.getDate() - 1);

            if (date.toDateString() === today.toDateString()) {
              return "Today";
            } else if (date.toDateString() === yesterday.toDateString()) {
              return "Yesterday";
            } else {
              return date.toLocaleDateString("en-US", {
                month: "long",
                day: "numeric",
              });
            }
          },

          groupMessagesByDate(messages) {
            const groups = {};
            messages.forEach((message) => {
              const date = new Date(message.timestamp);
              const dateStr = date.toDateString();
              if (!groups[dateStr]) {
                groups[dateStr] = [];
              }
              groups[dateStr].push(message);
            });
            return Object.entries(groups).map(([date, messages]) => ({
              date: new Date(date),
              messages,
            }));
          },

          async getUserDetails(userId) {
            try {
              const userDoc = await db.collection("USER").doc(userId).get();
              if (userDoc.exists) {
                const userData = userDoc.data();
                return {
                  firstName: userData.firstName || "",
                  lastName: userData.lastName || "",
                  profilePictureUrl: userData.profilePictureUrl,
                };
              }
              return {
                firstName: "Unknown",
                lastName: "User",
                profilePictureUrl: "/api/placeholder/40/40",
              };
            } catch (error) {
              console.error("Error fetching user details:", error);
              return {
                firstName: "Unknown",
                lastName: "User",
                profilePictureUrl: "/api/placeholder/40/40",
              };
            }
          },
          async initialize() {
            // Get current user
            const user = auth.currentUser;
            if (!user) return;

            this.currentUserId = user.uid;
            // Get current user's details including profile picture
            const currentUserDetails = await this.getUserDetails(
              this.currentUserId
            );
            this.currentUserProfilePic = currentUserDetails.profilePictureUrl;

            this.unsubscribe = db
              .collection("CHATS")
              .orderBy("timestamp", "desc")
              .where("from_user_id", "in", [this.currentUserId])
              .onSnapshot(async (snapshot) => {
                const chatMap = new Map();

                // Get received messages as well
                const receivedSnapshot = await db
                  .collection("CHATS")
                  .orderBy("timestamp", "desc")
                  .where("to_user_id", "==", this.currentUserId)
                  .get();

                // Process all messages
                const allDocs = [...snapshot.docs, ...receivedSnapshot.docs];

                for (const doc of allDocs) {
                  const data = doc.data();
                  const otherUserId =
                    data.from_user_id === this.currentUserId
                      ? data.to_user_id
                      : data.from_user_id;

                  if (
                    !chatMap.has(otherUserId) ||
                    chatMap.get(otherUserId).timestamp < data.timestamp
                  ) {
                    // Get user details from USER collection
                    const userDetails = await this.getUserDetails(otherUserId);

                    chatMap.set(otherUserId, {
                      userId: otherUserId,
                      firstName: userDetails.firstName,
                      lastName: userDetails.lastName,
                      profilePictureUrl: userDetails.profilePictureUrl,
                      lastMessage: data.message,
                      timestamp: data.timestamp,
                    });
                  }
                }

                this.chats = Array.from(chatMap.values());
                this.originalChats = [...this.chats];
              });
          },
          async selectChat(chat) {
            this.selectedChat = chat;
            await this.loadChatMessages();
          },
          async loadChatMessages() {
            if (!this.selectedChat) return;

            // Clean up previous message listener if it exists
            if (this.messageUnsubscribe) {
              this.messageUnsubscribe();
            }

            // Set up real-time listener for messages
            this.messageUnsubscribe = db
              .collection("CHATS")
              .where("from_user_id", "in", [
                this.currentUserId,
                this.selectedChat.userId,
              ])
              .where("to_user_id", "in", [
                this.currentUserId,
                this.selectedChat.userId,
              ])
              .orderBy("timestamp", "asc")
              .onSnapshot((snapshot) => {
                // Convert all timestamps to numbers for consistent comparison
                this.selectedChatMessages = snapshot.docs
                  .map((doc) => {
                    const data = doc.data();
                    const timestamp = data.timestamp?.seconds
                      ? data.timestamp.seconds * 1000
                      : typeof data.timestamp === "number"
                      ? data.timestamp
                      : Date.now();

                    return {
                      ...data,
                      id: doc.id,
                      timestamp,
                    };
                  })
                  .sort((a, b) => a.timestamp - b.timestamp);

                // Scroll to bottom when new messages arrive
                this.$nextTick(() => {
                  const container = this.$refs.messageContainer;
                  if (container) {
                    container.scrollTop = container.scrollHeight;
                  }
                });
              });
          },

          async sendMessage() {
            if (!this.newMessage.trim() || !this.selectedChat) return;

            // Add new message to database using server timestamp
            await db.collection("CHATS").add({
              from_user_id: this.currentUserId,
              to_user_id: this.selectedChat.userId,
              message: this.newMessage,
              timestamp: firebase.firestore.FieldValue.serverTimestamp(), // Use server timestamp
            });

            this.newMessage = "";
            await this.loadChatMessages();
          },

          formatTimestamp(timestamp) {
            if (!timestamp) return "Invalid Date";

            // Convert to number if it's a Firestore timestamp
            const timestampMs = timestamp?.seconds
              ? timestamp.seconds * 1000
              : timestamp;

            return new Date(timestampMs).toLocaleString();
          },

          async handleSearch() {
            if (!this.searchTerm.trim()) {
              this.searchResults = [];
              return;
            }

            const searchTermLower = this.searchTerm.toLowerCase();
            const contacts = new Map();
            const messages = [];

            // Search through existing chats for parent names
            this.chats.forEach((chat) => {
              const fullName =
                `${chat.firstName} ${chat.lastName}`.toLowerCase();
              if (fullName.includes(searchTermLower)) {
                contacts.set(chat.userId, {
                  ...chat,
                  matchType: "name",
                  highlightedName: this.highlightText(
                    `${chat.firstName} ${chat.lastName}`,
                    this.searchTerm
                  ),
                });
              }
            });

            // Search through messages
            const [sentMessages, receivedMessages] = await Promise.all([
              db
                .collection("CHATS")
                .where("from_user_id", "in", [this.currentUserId])
                .get(),
              db
                .collection("CHATS")
                .where("to_user_id", "in", [this.currentUserId])
                .get(),
            ]);

            // Process messages and group them by chat
            for (const querySnapshot of [sentMessages, receivedMessages]) {
              for (const doc of querySnapshot.docs) {
                const messageData = doc.data();
                if (
                  messageData.message.toLowerCase().includes(searchTermLower)
                ) {
                  const otherUserId =
                    messageData.from_user_id === this.currentUserId
                      ? messageData.to_user_id
                      : messageData.from_user_id;

                  const userDetails = await this.getUserDetails(otherUserId);

                  messages.push({
                    messageId: doc.id,
                    userId: otherUserId,
                    firstName: userDetails.firstName,
                    lastName: userDetails.lastName,
                    profilePictureUrl: userDetails.profilePictureUrl,
                    message: messageData.message,
                    highlightedMessage: this.highlightText(
                      messageData.message,
                      this.searchTerm
                    ),
                    timestamp: messageData.timestamp,
                    matchType: "message",
                  });
                }
              }
            }

            this.searchResults = {
              contacts: Array.from(contacts.values()),
              messages: messages,
            };
          },

          // Helper method to highlight matching text
          highlightText(text, searchTerm) {
            if (!searchTerm) return text;
            const regex = new RegExp(`(${searchTerm})`, "gi");
            return text.replace(regex, "<mark>$1</mark>");
          },

          // Method to scroll to and highlight a specific message
          async scrollToMessage(messageId, userId) {
            // First select the chat if needed
            const chat = this.chats.find((c) => c.userId === userId);
            if (
              chat &&
              (!this.selectedChat || this.selectedChat.userId !== userId)
            ) {
              await this.selectChat(chat);
            }

            // Wait for messages to load
            await this.$nextTick();

            // Set the highlighted message ID
            this.highlightedMessageId = messageId;

            // Find and scroll to the message
            const messageElement = document.querySelector(
              `[data-message-id="${messageId}"]`
            );
            if (messageElement) {
              messageElement.scrollIntoView({
                behavior: "smooth",
                block: "center",
              });

              // Remove highlight after animation
              setTimeout(() => {
                this.highlightedMessageId = null;
              }, 2000);
            }
          },
        },
        mounted() {
          // Check if user is logged in
          auth.onAuthStateChanged((user) => {
            if (user) {
              this.initialize();
            } else {
              // Redirect to login page or handle unauthorized access
              console.log("User not logged in");
            }
          });

          // To create icons
          this.$nextTick(() => {
            lucide.createIcons();
          });
        },

        // To handle dynamic updates
        updated() {
          this.$nextTick(() => {
            lucide.createIcons();
          });
        },

        beforeUnmount() {
          // Clean up listener
          if (this.unsubscribe) {
            this.unsubscribe();
          }
          if (this.messageUnsubscribe) {
            this.messageUnsubscribe();
          }
        },
      });

      app.mount("#app");
    </script>

    <script type="module">
      import { auth, db } from "./backend/firebase-config.js";
      import { onAuthStateChanged } from "https://www.gstatic.com/firebasejs/10.14.0/firebase-auth.js";
      import {
        doc,
        getDoc,
      } from "https://www.gstatic.com/firebasejs/10.14.0/firebase-firestore.js";
      import { logout } from "./backend/auth.js";

      async function loadNavbar(user) {
        let fileToLoad = "unloggedin_navbar_template.html";

        if (user) {
          try {
            const userDoc = await getDoc(doc(db, "USER", user.uid));
            if (userDoc.exists()) {
              const userData = userDoc.data();
              if (userData.role === "parent") {
                fileToLoad = "parent_navbar_template.html";
              } else if (userData.role === "nanny") {
                fileToLoad = "nanny_navbar_template.html";
              }
            }
          } catch (error) {
            console.error("Error fetching user role:", error);
          }
        }

        try {
          const response = await fetch(fileToLoad);
          if (!response.ok) throw new Error("Network response was not ok");

          const navbarHTML = await response.text();
          document.getElementById("navbar").innerHTML = navbarHTML;

          // Add event listener to logout link after navbar is loaded
          const logoutLink = document.querySelector("#logoutBtn");
          if (logoutLink) {
            logoutLink.addEventListener("click", async (e) => {
              e.preventDefault(); // Prevent the default link behavior
              console.log("Logout clicked");
              try {
                await logout(); // The redirect is now handled in the logout function
              } catch (error) {
                console.error("Logout failed:", error);
              }
            });
          } else {
            console.log("Logout link not found");
          }
        } catch (error) {
          console.error("Failed to load navbar:", error);
        }
      }

      onAuthStateChanged(auth, (user) => {
        console.log("Auth state changed");
        loadNavbar(user);
      });
    </script>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>

    <script>
      // Initialize Lucide icons
      lucide.createIcons();
    </script>
  </body>
</html>
